//#!/usr/bin/java --source 19

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package gradle.example;

import static com.fersca.lib.HttpCli.get;
import static com.fersca.lib.HttpCli.getFutureJson;
import static com.fersca.lib.HttpCli.getJson;
import static com.fersca.lib.HttpCli.json;
import static com.fersca.lib.Logger.println;
import static com.fersca.lib.Logger.setLogLevel;

//imports estandars
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.logging.Level;

import com.fersca.lib.HttpCli.FutureJson;
//Fersca Libs
import com.fersca.lib.HttpContext;
import com.fersca.lib.Server;

/**
 * La idea es probar todo lo necesario para poder hacer una Api rest:
 * 
 * - Poder atajar un request con un server (jetty) escuchando en el puerto 8080.
 * - Poder llamar a otras Apis de forma asyncrónica y syncrónica.
 * - Llamar a una API y procesar un json (gson).
 * - Compilarla a nativo para que funcione rápido (graalvm).
 * - Usar un build system para adminitras las dependencias (gradle).
 * - Probar un test.
 * 
 * @author Fernando.Scasserra
 * 
 */
public class App {
        
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) throws  Exception {
               
        setLogLevel(Level.INFO);
        
        var j = new App();
        var m = j.greetings();

        println(m);

        //Test Json Parsing
        String json = """
            {
                "name":"mkyong", 
                "age":33
            }
            """;

        var jsonMap = json(json);

        println(m);
        println(jsonMap.get("name"));
        println(jsonMap.get("age"));
        
        //get the json map from url
        var jsonMap2 = getJson("https://api.mercadolibre.com/users/20");        
        println(jsonMap2.get("nickname"));
        
        //get the json map with an async call
        FutureJson fJson = getFutureJson("https://api.mercadolibre.com/users/10");                
        
        //wait until json is available
        var jsonMap3 = fJson.getJson();        
        println(jsonMap3.get("nickname"));        
                
        //Concurrency Example
        j.concurrency();        
        
        //http server
        Server.createHttpServer();

        
        //Add the request handlers      
        Server.addController("/fernando", App::procesaUsuario,null);     
        Server.addController("/json", App::procesaUsuarioJson,null);
        Server.addController("/headers", App::procesaHeaders,null);        
        
        //debería devolver 200
        var result = get("http://localhost:8080/json");                        

        result = get("http://localhost:8080/fernando");                        
        result = get("http://localhost:8080/headers");                        
        
        //shutdown http server
        Server.shutdownWebserver();
        
    }
    
    private static void procesaUsuario(HttpContext context) {
        String mensage = "Ejecutó el métedoto procesaUsuario";
        context.write(mensage);
        println(mensage);
    }

    private static void procesaUsuarioJson(HttpContext context) {
        String mensage = "Ejecutó el métedoto procesaUsuarioJson";
        
        Map<String, Object> user = new HashMap<>();
        user.put("nombre", "Fernando");
        user.put("apellido", "Scasserra");
        user.put("edad", 42);
        user.put("hombre", true);
        user.put("padres", new String[]{"Mirta", "Norberto"});
                
        context.write(user);
        println(mensage);
    }

    private static void procesaHeaders(HttpContext context) {

        String mensaje ="""
                        <br>                                
                        <h4>Lista de Headers</h4>
                        """;
        
        context.print(mensaje);
        
        Enumeration<String> lista = context.getRequest().getHeaderNames();        
        while (lista.hasMoreElements()) {
            String header = lista.nextElement();
            context.print("<br>Header: " + header +" --- "+ context.getRequest().getHeader(header));
        }                                     
                                
        String nombreParam = context.getParameter("nombre");

        context.write("<br>Nombre: "+nombreParam);
    }
    
    private class RunableImpl implements Runnable {
        public void run() {
            println("Asynchronous task 0");
        }
    } 
    
    @SuppressWarnings("rawtypes")
	private class CallableImpl implements Callable {
        @Override
        public String call() throws InterruptedException {
            println("Asynchronous Callable task 0");
            Thread.sleep(1000);
            return "Callable 0";
        }
    } 

    
    private void concurrency() throws InterruptedException, ExecutionException {
        
        //Create an executor service with 10 threads
        //Uso el try with resourses para que se cierre el executor
        try (ExecutorService executorService = Executors.newFixedThreadPool(10)){
                  
            //One way to create a runnable is throught a class definition.
            var r0 = new RunableImpl();
            executorService.execute(r0);

            //Another way it to creathe the class inline in the parameter call.
            executorService.execute(new Runnable() {
                public void run() {
                    println("Asynchronous task 1");
                }
            });        

            //Another way is to create an inline object and assign it to a varieble
            var r2 = new Runnable() {
                public void run() {
                    println("Asynchronous task 2");
                }
            };        

            executorService.execute(r2);

            //Another way is with lambda expressions
            Runnable r3 = () -> {
                println("Asynchronous task 3");
            };        

            executorService.execute(r3);

            //other way is to send the lambda directly in the execution
            executorService.execute(() -> {
                println("Asynchronous task 4");
            });        

            //Send a Callable task (the callable return a value)
            var c1 = new CallableImpl();
            @SuppressWarnings({ "unchecked", "rawtypes" })
                    Future f1 = executorService.submit(c1);
            var futureValue = f1.get();
            println("Valor futuro: "+futureValue);

            //Smallest way -->
            @SuppressWarnings("rawtypes")
                    Callable c2 = () -> {
                println("Asynchronous Callable task 2");
                return "Callable task 2";
            };        

            @SuppressWarnings("unchecked")
                    var future2 = executorService.submit(c2);
            println("Valor futuro: "+future2.get());


            //Shutdown the executor
            executorService.shutdown();
        } 
               
    }

    protected String greetings() {
        return "Hola Fer";
    }
 
}