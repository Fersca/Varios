/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details take a look at the 'Building Java & JVM projects' chapter in the Gradle
 * User Manual available at https://docs.gradle.org/8.0.2/userguide/building_java_projects.html
 */


// https://central.sonatype.com/ -- Acá se pueden buscar los jars 

plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    id 'application'
    
    //Esto es para crear un Fat Jar
    id 'com.github.johnrengelman.shadow' version '8.1.1' 
    // https://imperceptiblethoughts.com/shadow/introduction/#benefits-of-shadow
    // Genera dentro del directorio build/distributions un file que se llama -shadow.tar el cual tiene 1 solo -jar 
    // Este plugin tira un warning en la version 9 de gradle porque dice que usa un método que se va a deprecar    
    /*
     * The CopyProcessingSpec.setFileMode(Integer) method has been deprecated. 
     * This is scheduled to be removed in Gradle 9.0. Please use the filePermissions(Action) method instead. 
     * 
     * 
     * En teoría hay un pull request hecho que va a fixear este tema
     * */
    
    
    id 'java'
    
    //Configurar Checkstyle (https://docs.gradle.org/current/userguide/checkstyle_plugin.html)   
    //Para que funcione tuve que bajarme dos archivos xml en donde estaba la configuración de sun y gogole.
    //Los tuve que poner en un directorio de configuración en el root del proyecto: {root}/config/checkstyle/checkstyle.xml
    //termina dejandp un reporte en el directorio de reportes.
    id 'checkstyle'
    
    id 'pmd'
    
    //https://plugins.gradle.org/plugin/se.solrike.sonarlint    
    //https://github.com/Lucas3oo/sonarlint-gradle-plugin
    id "se.solrike.sonarlint" version "2.0.0"
    
    //PlugIn de jacoco para el test coverage
    id 'jacoco'
    
    //Plugin para compilar nativo con graalvm
    id 'org.graalvm.buildtools.native' version '0.10.2'
    
    //Para TeaVM
    // https://www.teavm.org/docs/tooling/gradle.html
    id "org.teavm" version "0.8.1"
    
}

checkstyle {
    toolVersion = "10.12.4"
}
checkstyleMain {
    //para que no falle el build
    ignoreFailures = true
}

checkstyleTest {
    //para que no falle el build
    ignoreFailures = true
}

jacoco {
    toolVersion = "0.8.12" // Última version al 20/7/2024 https://github.com/jacoco/jacoco/releases
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
    
    /* -- Si pongo esta configuración parece que baja los sources y el javadoc, no lo probé.
    mavenCentral() {
        artifactTypes {
            artifactType("source", "jar", "sources")
            artifactType("doc", "jar", "javadoc")
        }
    }    
    */
}

dependencies {
    // Use JUnit test framework.
    testImplementation 'junit:junit:4.13.2'

    // This dependency is used by the application.
    //Fer: Lo saco, no se por que estaba esto...
    //implementation 'com.google.guava:guava:31.1-jre'
    implementation 'org.eclipse.jetty:jetty-server:11.0.13'
    implementation 'com.google.code.gson:gson:2.10.1'
    
    //https://www.slf4j.org/codes.html#noProviders 
    //-- es para evitar el warning de que no hay proveedor de log, alguna dependencia lo debe usar, creo que es jetty o el package de jakarta
    /*
     *  SLF4J: No SLF4J providers were found.
     *   SLF4J: Defaulting to no-operation (NOP) logger implementation
     *   SLF4J: See https://www.slf4j.org/codes.html#noProviders for further details.
     * 
    */
    implementation 'org.slf4j:slf4j-nop:2.0.7'

    //De sonarlint (Solo chequea Java)
    sonarlintPlugins 'org.sonarsource.java:sonar-java-plugin:7.30.1.34514'
        
}

pmd {
    consoleOutput = true
    toolVersion = "7.0.0"
    rulesMinimumPriority = 5
    ignoreFailures = true //para que el build no falle si hay errores
    ruleSets = ["category/java/errorprone.xml", "category/java/bestpractices.xml"]
}

application {
    // Define the main class for the application.
    //mainClass = 'gradle.example.App'
    mainClass = 'com.fersca.apicreator.Api'
}

jar {
  manifest {
    attributes 'Main-Class': 'gradle.example.App'
  }
}

sonarlint {
  //excludeRules = ['java:S1186']
  //includeRules = ['java:S1176', 'java:S1696', 'java:S4266']
  //ignoreFailures = false
  maxIssues = 15 // default 0
  //reportsDir = 'someFolder' // default build/reports/sonarlint
  // note that rule parameter names are case sensitive
  /*
  ruleParameters = [
    'java:S1176' : [
      'forClasses':'**.api.**',      // need javadoc for public methods in package matching 'api'
      'exclusion': '**.private.**'] // do not need javadoc for classes under 'private'. Default is **.internal.**
  ]
  */
  showIssues = true // default true
}

// Example to configure HTML report
sonarlintMain {
  reports {
    text.enabled = false // default false
    html {
      enabled = true // default false
      // default location build/reports/sonarlint/sonarlintMain.html
      outputLocation = layout.buildDirectory.file('my_sonarlint_super_report.html')
    }
    xml.enabled = false // default false
    sarif.enabled = false // default false
  }
}

graalvmNative {
    
     binaries.all {
         resources.autodetect()
         
         //En teoría esto es para activar los features preview (virtual threads) en momento de compilar
         //https://graalvm.github.io/native-build-tools/latest/gradle-plugin.html 
         buildArgs.add('--enable-preview')         
        
        //Error: Darwin native toolchain (x86_64) implies native-image target architecture class jdk.vm.ci.amd64.AMD64 but configured native-image target architecture is class jdk.vm.ci.aarch64.AArch64.
        //Error: To prevent native-toolchain checking provide command-line option -H:-CheckToolchain
                
        /*
         * https://github.com/oracle/graal/issues/4694
         * En esa página dice que el problema está con que el compilador switchea de arquitectura de x86 a arm.
         * cuando ejecuto el comando arch o file sobre los archivos me dicen que están todos en arm, por eso funciona desde la terminal
         * se ve que cuando ejecuta gradle, no es así, y lo toma como x86
         * */
     }
          
    toolchainDetection = true
     
}

/*
 * Tuve que agregarle esto, porque cada vez que corría un run, parece que la tarea quedaba
 * cacheada como que ya estaba lista y luego la próxima vez que la corría, no la ejecutaba.
 * Al inficarle que la tarea run no está up-to-date, la corre siempre, es raro que esto no venga
 * así por default.
 * Me di cuenta al ejecutar un gradlew run --info en donde decía: Skipping task ':app:run' as it is up-to-date 
*/

tasks.named('run') {
    outputs.upToDateWhen { false }
}

/* lo saco cuando deshabilito el plugin */
teavm.js {
    addedToWebApp = true
    mainClass = "gradle.example.TeaExample"
    
    // this is also optional, default value is <project name>.js
    targetFileName = "example.js"
}

test {

    useJUnit() // Configura Gradle para usar JUnit 4
    
    // Configuración del logging de pruebas
    testLogging {
        // Mostrar eventos de pruebas: passed, skipped, failed
        events "passed", "skipped", "failed"
        
        // Mostrar resultados detallados en la consola
        showStandardStreams = true

        // Formato completo de excepción para mostrar detalles en caso de error
        exceptionFormat = 'full'
    }
    
    // Forzar la ejecución de las pruebas
    outputs.upToDateWhen { false }
    finalizedBy jacocoTestReport
    
}

tasks.withType(JavaCompile) {
    options.compilerArgs << "-Xlint:unchecked" //<< "-Xlint:deprecation"
    options.compilerArgs.add('--enable-preview')
}

jacocoTestReport {
    
    dependsOn test // El reporte de JaCoCo depende de que las pruebas se ejecuten primero
    
    reports {
        xml.required = true // Habilitar el reporte XML
        csv.required = false
        html.required = true
        html.outputLocation = layout.buildDirectory.dir('jacocoHtml')
        //Se agrega esta línea así la puede analizar la última tarea que la muestra en la línea de comando
        xml.outputLocation = layout.buildDirectory.file('jacoco/jacocoTestReport.xml')        
    }
}


/*
 * Esta es una tarea personalizada que se agrega para poder ver el code coverage que hace Jacoco
 * pero en la línea de comando cuando se corren los test en la consola 
 *   def reportFile = file("${buildDir}/jacoco/jacocoTestReport.xml")
*/
       
import javax.xml.parsers.SAXParserFactory
import org.xml.sax.helpers.DefaultHandler
import org.xml.sax.EntityResolver
import org.xml.sax.InputSource
import groovy.xml.XmlParser

task printCoverageReport {

    dependsOn jacocoTestReport

    doLast {

        def reportFile = file("${buildDir}/jacoco/jacocoTestReport.xml")

        if (reportFile.exists()) {

            // Configurar SAXParserFactory para permitir DOCTYPE y deshabilitar validación DTD
            SAXParserFactory factory = SAXParserFactory.newInstance()
            factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
            factory.setFeature("http://xml.org/sax/features/external-general-entities", true)
            factory.setFeature("http://xml.org/sax/features/external-parameter-entities", true)
            factory.setNamespaceAware(true)

            def saxParser = factory.newSAXParser()

            // Configurar el XmlParser con un EntityResolver para ignorar la validación DTD
            def parser = new XmlParser(saxParser)
            parser.setEntityResolver(new EntityResolver() {
                @Override
                InputSource resolveEntity(String publicId, String systemId) {
                    if (systemId.contains("report.dtd")) {
                        return new InputSource(new StringReader(""))
                    }
                    return null
                }
            })

            def report = parser.parse(reportFile)

            def counter = report.counter.find { it.@type == 'INSTRUCTION' }
            def missed = counter.@missed.toInteger()
            def covered = counter.@covered.toInteger()
            def total = missed + covered
            def coverage = (covered / total) * 100

            // Códigos de escape ANSI para rojo y negrita
            def redBold = "\033[1;31m"
            def reset = "\033[0m"

            println "${redBold}Total Coverage: ${String.format('%.2f', coverage)}%${reset}"

            
        } else {

            println "No coverage report found."
        }
    }
}

// Ejecutar printCoverageReport después de test
test.finalizedBy printCoverageReport

// Asegurarse de que printCoverageReport se ejecute también al final de build
build.dependsOn printCoverageReport
